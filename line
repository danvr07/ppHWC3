module Parser (parseLambda, parseLine) where

import Control.Monad
import Control.Applicative
import Data.Char (isAlpha, isAlphaNum)

import Lambda
import Binding

newtype Parser a = Parser { parse :: String -> Maybe (a, String) }

-- Instance Monad for Parser
instance Monad Parser where
    return v = Parser $ \s -> Just (v, s)
    mp >>= f = Parser $ \s -> case parse mp s of
                                Nothing -> Nothing
                                Just (v, rest) -> parse (f v) rest

-- Instance Applicative for Parser
instance Applicative Parser where
    af <*> mp = do
        f <- af
        v <- mp
        return $ f v
    pure = return

-- Instance Functor for Parser
instance Functor Parser where
    fmap f mp = do
        x <- mp
        return $ f x

-- Instance Alternative for Parser
instance Alternative Parser where
    empty = Parser $ \_ -> Nothing
    p1 <|> p2 = Parser $ \s -> case parse p1 s of
                                Nothing -> parse p2 s
                                res -> res

--------
plusParser :: Parser a -> Parser [a]
plusParser p = do
    x <- p
    xs <- starParser p
    return (x:xs)

starParser :: Parser a -> Parser [a]
starParser p = plusParser p <|> return []

-- Basic parsers
charParser :: Char -> Parser Char
charParser c = Parser $ \s ->
    case s of
        [] -> Nothing
        (x:xs) -> if x == c then Just (x, xs) else Nothing

predicateParser :: (Char -> Bool) -> Parser Char
predicateParser p = Parser $ \s ->
    case s of
        [] -> Nothing
        (x:xs) -> if p x then Just (x, xs) else Nothing

whitespaceParser :: Parser String
whitespaceParser = starParser (charParser ' ')

-- Parsers for variables and identifiers
varParser :: Parser String
varParser = do
    x <- predicateParser isAlpha
    xs <- many (predicateParser isAlphaNum)
    return (x:xs)

macroParser :: Parser Lambda
macroParser = do
    charParser '#'
    name <- varParser
    return (Macro name)

-- Parsers for lambda terms
varExprParser :: Parser Lambda
varExprParser = Var <$> varParser

absParser :: Parser Lambda
absParser = do
    charParser '\\' <|> charParser 'Î»'
    whitespaceParser
    var <- varParser
    whitespaceParser
    charParser '.'
    whitespaceParser
    body <- exprParser
    return (Abs var body)

appParser :: Parser Lambda
appParser = do
    charParser '('
    whitespaceParser
    e1 <- exprParser
    whitespaceParser
    e2 <- exprParser
    whitespaceParser
    charParser ')'
    return (App e1 e2)

-- Parsers for complete expressions
exprParser :: Parser Lambda
exprParser = absParser <|> appParser <|> varExprParser <|> macroParser

parenExprParser :: Parser Lambda
parenExprParser = do
    charParser '('
    whitespaceParser
    e <- exprParser
    whitespaceParser
    charParser ')'
    return e

-- Main parsing function that returns a Lambda
parseLambda :: String -> Lambda
parseLambda input = case parse exprParser input of
    Nothing -> error "Parse error: invalid input"
    Just (result, _) -> result

-- Line parsers
bindingParser :: Parser Line
bindingParser = do
    name <- varParser
    whitespaceParser
    charParser '='
    whitespaceParser
    expr <- exprParser
    return (Binding name expr)

evalParser :: Parser Line
evalParser = Eval <$> exprParser

lineParser :: Parser Line
lineParser = bindingParser <|> evalParser

parseLine :: String -> Either String Line
parseLine input = case parse lineParser input of
    Nothing -> Left "Parse error: invalid input"
    Just (result, _) -> Right result
